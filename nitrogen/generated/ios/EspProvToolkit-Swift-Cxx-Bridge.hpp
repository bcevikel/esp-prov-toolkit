///
/// EspProvToolkit-Swift-Cxx-Bridge.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

// Forward declarations of C++ defined types
// Forward declaration of `HybridEspProvToolkitSpec` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { class HybridEspProvToolkitSpec; }
// Forward declaration of `PTBooleanResult` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { struct PTBooleanResult; }
// Forward declaration of `PTDeviceResult` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { struct PTDeviceResult; }
// Forward declaration of `PTDevice` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { struct PTDevice; }
// Forward declaration of `PTLocationAccess` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { enum class PTLocationAccess; }
// Forward declaration of `PTProvisionResult` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { struct PTProvisionResult; }
// Forward declaration of `PTResult` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { struct PTResult; }
// Forward declaration of `PTSearchResult` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { struct PTSearchResult; }
// Forward declaration of `PTSecurity` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { enum class PTSecurity; }
// Forward declaration of `PTSessionResult` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { struct PTSessionResult; }
// Forward declaration of `PTSessionStatus` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { enum class PTSessionStatus; }
// Forward declaration of `PTStringResult` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { struct PTStringResult; }
// Forward declaration of `PTTransport` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { enum class PTTransport; }
// Forward declaration of `PTWifiEntry` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { struct PTWifiEntry; }
// Forward declaration of `PTWifiScanResult` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { struct PTWifiScanResult; }

// Forward declarations of Swift defined types
// Forward declaration of `HybridEspProvToolkitSpec_cxx` to properly resolve imports.
namespace EspProvToolkit { class HybridEspProvToolkitSpec_cxx; }

// Include C++ defined types
#include "HybridEspProvToolkitSpec.hpp"
#include "PTBooleanResult.hpp"
#include "PTDevice.hpp"
#include "PTDeviceResult.hpp"
#include "PTLocationAccess.hpp"
#include "PTProvisionResult.hpp"
#include "PTResult.hpp"
#include "PTSearchResult.hpp"
#include "PTSecurity.hpp"
#include "PTSessionResult.hpp"
#include "PTSessionStatus.hpp"
#include "PTStringResult.hpp"
#include "PTTransport.hpp"
#include "PTWifiEntry.hpp"
#include "PTWifiScanResult.hpp"
#include <NitroModules/Promise.hpp>
#include <NitroModules/PromiseHolder.hpp>
#include <NitroModules/Result.hpp>
#include <exception>
#include <functional>
#include <memory>
#include <optional>
#include <string>
#include <vector>

/**
 * Contains specialized versions of C++ templated types so they can be accessed from Swift,
 * as well as helper functions to interact with those C++ types from Swift.
 */
namespace margelo::nitro::espprovtoolkit::bridge::swift {

  // pragma MARK: std::vector<std::string>
  /**
   * Specialized version of `std::vector<std::string>`.
   */
  using std__vector_std__string_ = std::vector<std::string>;
  inline std::vector<std::string> create_std__vector_std__string_(size_t size) {
    std::vector<std::string> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<std::string>>
  /**
   * Specialized version of `std::optional<std::vector<std::string>>`.
   */
  using std__optional_std__vector_std__string__ = std::optional<std::vector<std::string>>;
  inline std::optional<std::vector<std::string>> create_std__optional_std__vector_std__string__(const std::vector<std::string>& value) {
    return std::optional<std::vector<std::string>>(value);
  }
  
  // pragma MARK: std::optional<double>
  /**
   * Specialized version of `std::optional<double>`.
   */
  using std__optional_double_ = std::optional<double>;
  inline std::optional<double> create_std__optional_double_(const double& value) {
    return std::optional<double>(value);
  }
  
  // pragma MARK: std::shared_ptr<Promise<PTSearchResult>>
  /**
   * Specialized version of `std::shared_ptr<Promise<PTSearchResult>>`.
   */
  using std__shared_ptr_Promise_PTSearchResult__ = std::shared_ptr<Promise<PTSearchResult>>;
  inline std::shared_ptr<Promise<PTSearchResult>> create_std__shared_ptr_Promise_PTSearchResult__() {
    return Promise<PTSearchResult>::create();
  }
  inline PromiseHolder<PTSearchResult> wrap_std__shared_ptr_Promise_PTSearchResult__(std::shared_ptr<Promise<PTSearchResult>> promise) {
    return PromiseHolder<PTSearchResult>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const PTSearchResult& /* result */)>
  /**
   * Specialized version of `std::function<void(const PTSearchResult&)>`.
   */
  using Func_void_PTSearchResult = std::function<void(const PTSearchResult& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const PTSearchResult& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_PTSearchResult_Wrapper final {
  public:
    explicit Func_void_PTSearchResult_Wrapper(std::function<void(const PTSearchResult& /* result */)>&& func): _function(std::make_shared<std::function<void(const PTSearchResult& /* result */)>>(std::move(func))) {}
    inline void call(PTSearchResult result) const {
      _function->operator()(result);
    }
  private:
    std::shared_ptr<std::function<void(const PTSearchResult& /* result */)>> _function;
  };
  Func_void_PTSearchResult create_Func_void_PTSearchResult(void* _Nonnull swiftClosureWrapper);
  inline Func_void_PTSearchResult_Wrapper wrap_Func_void_PTSearchResult(Func_void_PTSearchResult value) {
    return Func_void_PTSearchResult_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const std::exception_ptr& /* error */)>
  /**
   * Specialized version of `std::function<void(const std::exception_ptr&)>`.
   */
  using Func_void_std__exception_ptr = std::function<void(const std::exception_ptr& /* error */)>;
  /**
   * Wrapper class for a `std::function<void(const std::exception_ptr& / * error * /)>`, this can be used from Swift.
   */
  class Func_void_std__exception_ptr_Wrapper final {
  public:
    explicit Func_void_std__exception_ptr_Wrapper(std::function<void(const std::exception_ptr& /* error */)>&& func): _function(std::make_shared<std::function<void(const std::exception_ptr& /* error */)>>(std::move(func))) {}
    inline void call(std::exception_ptr error) const {
      _function->operator()(error);
    }
  private:
    std::shared_ptr<std::function<void(const std::exception_ptr& /* error */)>> _function;
  };
  Func_void_std__exception_ptr create_Func_void_std__exception_ptr(void* _Nonnull swiftClosureWrapper);
  inline Func_void_std__exception_ptr_Wrapper wrap_Func_void_std__exception_ptr(Func_void_std__exception_ptr value) {
    return Func_void_std__exception_ptr_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<PTResult>>
  /**
   * Specialized version of `std::shared_ptr<Promise<PTResult>>`.
   */
  using std__shared_ptr_Promise_PTResult__ = std::shared_ptr<Promise<PTResult>>;
  inline std::shared_ptr<Promise<PTResult>> create_std__shared_ptr_Promise_PTResult__() {
    return Promise<PTResult>::create();
  }
  inline PromiseHolder<PTResult> wrap_std__shared_ptr_Promise_PTResult__(std::shared_ptr<Promise<PTResult>> promise) {
    return PromiseHolder<PTResult>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const PTResult& /* result */)>
  /**
   * Specialized version of `std::function<void(const PTResult&)>`.
   */
  using Func_void_PTResult = std::function<void(const PTResult& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const PTResult& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_PTResult_Wrapper final {
  public:
    explicit Func_void_PTResult_Wrapper(std::function<void(const PTResult& /* result */)>&& func): _function(std::make_shared<std::function<void(const PTResult& /* result */)>>(std::move(func))) {}
    inline void call(PTResult result) const {
      _function->operator()(result);
    }
  private:
    std::shared_ptr<std::function<void(const PTResult& /* result */)>> _function;
  };
  Func_void_PTResult create_Func_void_PTResult(void* _Nonnull swiftClosureWrapper);
  inline Func_void_PTResult_Wrapper wrap_Func_void_PTResult(Func_void_PTResult value) {
    return Func_void_PTResult_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::string>
  /**
   * Specialized version of `std::optional<std::string>`.
   */
  using std__optional_std__string_ = std::optional<std::string>;
  inline std::optional<std::string> create_std__optional_std__string_(const std::string& value) {
    return std::optional<std::string>(value);
  }
  
  // pragma MARK: std::optional<bool>
  /**
   * Specialized version of `std::optional<bool>`.
   */
  using std__optional_bool_ = std::optional<bool>;
  inline std::optional<bool> create_std__optional_bool_(const bool& value) {
    return std::optional<bool>(value);
  }
  
  // pragma MARK: std::optional<PTDevice>
  /**
   * Specialized version of `std::optional<PTDevice>`.
   */
  using std__optional_PTDevice_ = std::optional<PTDevice>;
  inline std::optional<PTDevice> create_std__optional_PTDevice_(const PTDevice& value) {
    return std::optional<PTDevice>(value);
  }
  
  // pragma MARK: std::vector<PTWifiEntry>
  /**
   * Specialized version of `std::vector<PTWifiEntry>`.
   */
  using std__vector_PTWifiEntry_ = std::vector<PTWifiEntry>;
  inline std::vector<PTWifiEntry> create_std__vector_PTWifiEntry_(size_t size) {
    std::vector<PTWifiEntry> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<PTWifiEntry>>
  /**
   * Specialized version of `std::optional<std::vector<PTWifiEntry>>`.
   */
  using std__optional_std__vector_PTWifiEntry__ = std::optional<std::vector<PTWifiEntry>>;
  inline std::optional<std::vector<PTWifiEntry>> create_std__optional_std__vector_PTWifiEntry__(const std::vector<PTWifiEntry>& value) {
    return std::optional<std::vector<PTWifiEntry>>(value);
  }
  
  // pragma MARK: std::shared_ptr<Promise<PTWifiScanResult>>
  /**
   * Specialized version of `std::shared_ptr<Promise<PTWifiScanResult>>`.
   */
  using std__shared_ptr_Promise_PTWifiScanResult__ = std::shared_ptr<Promise<PTWifiScanResult>>;
  inline std::shared_ptr<Promise<PTWifiScanResult>> create_std__shared_ptr_Promise_PTWifiScanResult__() {
    return Promise<PTWifiScanResult>::create();
  }
  inline PromiseHolder<PTWifiScanResult> wrap_std__shared_ptr_Promise_PTWifiScanResult__(std::shared_ptr<Promise<PTWifiScanResult>> promise) {
    return PromiseHolder<PTWifiScanResult>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const PTWifiScanResult& /* result */)>
  /**
   * Specialized version of `std::function<void(const PTWifiScanResult&)>`.
   */
  using Func_void_PTWifiScanResult = std::function<void(const PTWifiScanResult& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const PTWifiScanResult& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_PTWifiScanResult_Wrapper final {
  public:
    explicit Func_void_PTWifiScanResult_Wrapper(std::function<void(const PTWifiScanResult& /* result */)>&& func): _function(std::make_shared<std::function<void(const PTWifiScanResult& /* result */)>>(std::move(func))) {}
    inline void call(PTWifiScanResult result) const {
      _function->operator()(result);
    }
  private:
    std::shared_ptr<std::function<void(const PTWifiScanResult& /* result */)>> _function;
  };
  Func_void_PTWifiScanResult create_Func_void_PTWifiScanResult(void* _Nonnull swiftClosureWrapper);
  inline Func_void_PTWifiScanResult_Wrapper wrap_Func_void_PTWifiScanResult(Func_void_PTWifiScanResult value) {
    return Func_void_PTWifiScanResult_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<PTSessionStatus>
  /**
   * Specialized version of `std::optional<PTSessionStatus>`.
   */
  using std__optional_PTSessionStatus_ = std::optional<PTSessionStatus>;
  inline std::optional<PTSessionStatus> create_std__optional_PTSessionStatus_(const PTSessionStatus& value) {
    return std::optional<PTSessionStatus>(value);
  }
  
  // pragma MARK: std::shared_ptr<Promise<PTSessionResult>>
  /**
   * Specialized version of `std::shared_ptr<Promise<PTSessionResult>>`.
   */
  using std__shared_ptr_Promise_PTSessionResult__ = std::shared_ptr<Promise<PTSessionResult>>;
  inline std::shared_ptr<Promise<PTSessionResult>> create_std__shared_ptr_Promise_PTSessionResult__() {
    return Promise<PTSessionResult>::create();
  }
  inline PromiseHolder<PTSessionResult> wrap_std__shared_ptr_Promise_PTSessionResult__(std::shared_ptr<Promise<PTSessionResult>> promise) {
    return PromiseHolder<PTSessionResult>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const PTSessionResult& /* result */)>
  /**
   * Specialized version of `std::function<void(const PTSessionResult&)>`.
   */
  using Func_void_PTSessionResult = std::function<void(const PTSessionResult& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const PTSessionResult& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_PTSessionResult_Wrapper final {
  public:
    explicit Func_void_PTSessionResult_Wrapper(std::function<void(const PTSessionResult& /* result */)>&& func): _function(std::make_shared<std::function<void(const PTSessionResult& /* result */)>>(std::move(func))) {}
    inline void call(PTSessionResult result) const {
      _function->operator()(result);
    }
  private:
    std::shared_ptr<std::function<void(const PTSessionResult& /* result */)>> _function;
  };
  Func_void_PTSessionResult create_Func_void_PTSessionResult(void* _Nonnull swiftClosureWrapper);
  inline Func_void_PTSessionResult_Wrapper wrap_Func_void_PTSessionResult(Func_void_PTSessionResult value) {
    return Func_void_PTSessionResult_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<PTProvisionResult>>
  /**
   * Specialized version of `std::shared_ptr<Promise<PTProvisionResult>>`.
   */
  using std__shared_ptr_Promise_PTProvisionResult__ = std::shared_ptr<Promise<PTProvisionResult>>;
  inline std::shared_ptr<Promise<PTProvisionResult>> create_std__shared_ptr_Promise_PTProvisionResult__() {
    return Promise<PTProvisionResult>::create();
  }
  inline PromiseHolder<PTProvisionResult> wrap_std__shared_ptr_Promise_PTProvisionResult__(std::shared_ptr<Promise<PTProvisionResult>> promise) {
    return PromiseHolder<PTProvisionResult>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const PTProvisionResult& /* result */)>
  /**
   * Specialized version of `std::function<void(const PTProvisionResult&)>`.
   */
  using Func_void_PTProvisionResult = std::function<void(const PTProvisionResult& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const PTProvisionResult& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_PTProvisionResult_Wrapper final {
  public:
    explicit Func_void_PTProvisionResult_Wrapper(std::function<void(const PTProvisionResult& /* result */)>&& func): _function(std::make_shared<std::function<void(const PTProvisionResult& /* result */)>>(std::move(func))) {}
    inline void call(PTProvisionResult result) const {
      _function->operator()(result);
    }
  private:
    std::shared_ptr<std::function<void(const PTProvisionResult& /* result */)>> _function;
  };
  Func_void_PTProvisionResult create_Func_void_PTProvisionResult(void* _Nonnull swiftClosureWrapper);
  inline Func_void_PTProvisionResult_Wrapper wrap_Func_void_PTProvisionResult(Func_void_PTProvisionResult value) {
    return Func_void_PTProvisionResult_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<PTStringResult>>
  /**
   * Specialized version of `std::shared_ptr<Promise<PTStringResult>>`.
   */
  using std__shared_ptr_Promise_PTStringResult__ = std::shared_ptr<Promise<PTStringResult>>;
  inline std::shared_ptr<Promise<PTStringResult>> create_std__shared_ptr_Promise_PTStringResult__() {
    return Promise<PTStringResult>::create();
  }
  inline PromiseHolder<PTStringResult> wrap_std__shared_ptr_Promise_PTStringResult__(std::shared_ptr<Promise<PTStringResult>> promise) {
    return PromiseHolder<PTStringResult>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const PTStringResult& /* result */)>
  /**
   * Specialized version of `std::function<void(const PTStringResult&)>`.
   */
  using Func_void_PTStringResult = std::function<void(const PTStringResult& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const PTStringResult& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_PTStringResult_Wrapper final {
  public:
    explicit Func_void_PTStringResult_Wrapper(std::function<void(const PTStringResult& /* result */)>&& func): _function(std::make_shared<std::function<void(const PTStringResult& /* result */)>>(std::move(func))) {}
    inline void call(PTStringResult result) const {
      _function->operator()(result);
    }
  private:
    std::shared_ptr<std::function<void(const PTStringResult& /* result */)>> _function;
  };
  Func_void_PTStringResult create_Func_void_PTStringResult(void* _Nonnull swiftClosureWrapper);
  inline Func_void_PTStringResult_Wrapper wrap_Func_void_PTStringResult(Func_void_PTStringResult value) {
    return Func_void_PTStringResult_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<std::shared_ptr<Promise<bool>>(PTLocationAccess /* level */)>
  /**
   * Specialized version of `std::function<std::shared_ptr<Promise<bool>>(PTLocationAccess)>`.
   */
  using Func_std__shared_ptr_Promise_bool___PTLocationAccess = std::function<std::shared_ptr<Promise<bool>>(PTLocationAccess /* level */)>;
  /**
   * Wrapper class for a `std::function<std::shared_ptr<Promise<bool>>(PTLocationAccess / * level * /)>`, this can be used from Swift.
   */
  class Func_std__shared_ptr_Promise_bool___PTLocationAccess_Wrapper final {
  public:
    explicit Func_std__shared_ptr_Promise_bool___PTLocationAccess_Wrapper(std::function<std::shared_ptr<Promise<bool>>(PTLocationAccess /* level */)>&& func): _function(std::make_shared<std::function<std::shared_ptr<Promise<bool>>(PTLocationAccess /* level */)>>(std::move(func))) {}
    inline std::shared_ptr<Promise<bool>> call(int level) const {
      auto __result = _function->operator()(static_cast<PTLocationAccess>(level));
      return __result;
    }
  private:
    std::shared_ptr<std::function<std::shared_ptr<Promise<bool>>(PTLocationAccess /* level */)>> _function;
  };
  Func_std__shared_ptr_Promise_bool___PTLocationAccess create_Func_std__shared_ptr_Promise_bool___PTLocationAccess(void* _Nonnull swiftClosureWrapper);
  inline Func_std__shared_ptr_Promise_bool___PTLocationAccess_Wrapper wrap_Func_std__shared_ptr_Promise_bool___PTLocationAccess(Func_std__shared_ptr_Promise_bool___PTLocationAccess value) {
    return Func_std__shared_ptr_Promise_bool___PTLocationAccess_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<bool>>
  /**
   * Specialized version of `std::shared_ptr<Promise<bool>>`.
   */
  using std__shared_ptr_Promise_bool__ = std::shared_ptr<Promise<bool>>;
  inline std::shared_ptr<Promise<bool>> create_std__shared_ptr_Promise_bool__() {
    return Promise<bool>::create();
  }
  inline PromiseHolder<bool> wrap_std__shared_ptr_Promise_bool__(std::shared_ptr<Promise<bool>> promise) {
    return PromiseHolder<bool>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(bool /* result */)>
  /**
   * Specialized version of `std::function<void(bool)>`.
   */
  using Func_void_bool = std::function<void(bool /* result */)>;
  /**
   * Wrapper class for a `std::function<void(bool / * result * /)>`, this can be used from Swift.
   */
  class Func_void_bool_Wrapper final {
  public:
    explicit Func_void_bool_Wrapper(std::function<void(bool /* result */)>&& func): _function(std::make_shared<std::function<void(bool /* result */)>>(std::move(func))) {}
    inline void call(bool result) const {
      _function->operator()(result);
    }
  private:
    std::shared_ptr<std::function<void(bool /* result */)>> _function;
  };
  Func_void_bool create_Func_void_bool(void* _Nonnull swiftClosureWrapper);
  inline Func_void_bool_Wrapper wrap_Func_void_bool(Func_void_bool value) {
    return Func_void_bool_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<margelo::nitro::espprovtoolkit::HybridEspProvToolkitSpec>
  /**
   * Specialized version of `std::shared_ptr<margelo::nitro::espprovtoolkit::HybridEspProvToolkitSpec>`.
   */
  using std__shared_ptr_margelo__nitro__espprovtoolkit__HybridEspProvToolkitSpec_ = std::shared_ptr<margelo::nitro::espprovtoolkit::HybridEspProvToolkitSpec>;
  std::shared_ptr<margelo::nitro::espprovtoolkit::HybridEspProvToolkitSpec> create_std__shared_ptr_margelo__nitro__espprovtoolkit__HybridEspProvToolkitSpec_(void* _Nonnull swiftUnsafePointer);
  void* _Nonnull get_std__shared_ptr_margelo__nitro__espprovtoolkit__HybridEspProvToolkitSpec_(std__shared_ptr_margelo__nitro__espprovtoolkit__HybridEspProvToolkitSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<margelo::nitro::espprovtoolkit::HybridEspProvToolkitSpec>
  using std__weak_ptr_margelo__nitro__espprovtoolkit__HybridEspProvToolkitSpec_ = std::weak_ptr<margelo::nitro::espprovtoolkit::HybridEspProvToolkitSpec>;
  inline std__weak_ptr_margelo__nitro__espprovtoolkit__HybridEspProvToolkitSpec_ weakify_std__shared_ptr_margelo__nitro__espprovtoolkit__HybridEspProvToolkitSpec_(const std::shared_ptr<margelo::nitro::espprovtoolkit::HybridEspProvToolkitSpec>& strong) { return strong; }
  
  // pragma MARK: Result<std::shared_ptr<Promise<PTSearchResult>>>
  using Result_std__shared_ptr_Promise_PTSearchResult___ = Result<std::shared_ptr<Promise<PTSearchResult>>>;
  inline Result_std__shared_ptr_Promise_PTSearchResult___ create_Result_std__shared_ptr_Promise_PTSearchResult___(const std::shared_ptr<Promise<PTSearchResult>>& value) {
    return Result<std::shared_ptr<Promise<PTSearchResult>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_PTSearchResult___ create_Result_std__shared_ptr_Promise_PTSearchResult___(const std::exception_ptr& error) {
    return Result<std::shared_ptr<Promise<PTSearchResult>>>::withError(error);
  }
  
  // pragma MARK: Result<void>
  using Result_void_ = Result<void>;
  inline Result_void_ create_Result_void_() {
    return Result<void>::withValue();
  }
  inline Result_void_ create_Result_void_(const std::exception_ptr& error) {
    return Result<void>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<PTResult>>>
  using Result_std__shared_ptr_Promise_PTResult___ = Result<std::shared_ptr<Promise<PTResult>>>;
  inline Result_std__shared_ptr_Promise_PTResult___ create_Result_std__shared_ptr_Promise_PTResult___(const std::shared_ptr<Promise<PTResult>>& value) {
    return Result<std::shared_ptr<Promise<PTResult>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_PTResult___ create_Result_std__shared_ptr_Promise_PTResult___(const std::exception_ptr& error) {
    return Result<std::shared_ptr<Promise<PTResult>>>::withError(error);
  }
  
  // pragma MARK: Result<PTDeviceResult>
  using Result_PTDeviceResult_ = Result<PTDeviceResult>;
  inline Result_PTDeviceResult_ create_Result_PTDeviceResult_(const PTDeviceResult& value) {
    return Result<PTDeviceResult>::withValue(value);
  }
  inline Result_PTDeviceResult_ create_Result_PTDeviceResult_(const std::exception_ptr& error) {
    return Result<PTDeviceResult>::withError(error);
  }
  
  // pragma MARK: Result<bool>
  using Result_bool_ = Result<bool>;
  inline Result_bool_ create_Result_bool_(bool value) {
    return Result<bool>::withValue(std::move(value));
  }
  inline Result_bool_ create_Result_bool_(const std::exception_ptr& error) {
    return Result<bool>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<PTWifiScanResult>>>
  using Result_std__shared_ptr_Promise_PTWifiScanResult___ = Result<std::shared_ptr<Promise<PTWifiScanResult>>>;
  inline Result_std__shared_ptr_Promise_PTWifiScanResult___ create_Result_std__shared_ptr_Promise_PTWifiScanResult___(const std::shared_ptr<Promise<PTWifiScanResult>>& value) {
    return Result<std::shared_ptr<Promise<PTWifiScanResult>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_PTWifiScanResult___ create_Result_std__shared_ptr_Promise_PTWifiScanResult___(const std::exception_ptr& error) {
    return Result<std::shared_ptr<Promise<PTWifiScanResult>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<PTSessionResult>>>
  using Result_std__shared_ptr_Promise_PTSessionResult___ = Result<std::shared_ptr<Promise<PTSessionResult>>>;
  inline Result_std__shared_ptr_Promise_PTSessionResult___ create_Result_std__shared_ptr_Promise_PTSessionResult___(const std::shared_ptr<Promise<PTSessionResult>>& value) {
    return Result<std::shared_ptr<Promise<PTSessionResult>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_PTSessionResult___ create_Result_std__shared_ptr_Promise_PTSessionResult___(const std::exception_ptr& error) {
    return Result<std::shared_ptr<Promise<PTSessionResult>>>::withError(error);
  }
  
  // pragma MARK: Result<PTResult>
  using Result_PTResult_ = Result<PTResult>;
  inline Result_PTResult_ create_Result_PTResult_(const PTResult& value) {
    return Result<PTResult>::withValue(value);
  }
  inline Result_PTResult_ create_Result_PTResult_(const std::exception_ptr& error) {
    return Result<PTResult>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<PTProvisionResult>>>
  using Result_std__shared_ptr_Promise_PTProvisionResult___ = Result<std::shared_ptr<Promise<PTProvisionResult>>>;
  inline Result_std__shared_ptr_Promise_PTProvisionResult___ create_Result_std__shared_ptr_Promise_PTProvisionResult___(const std::shared_ptr<Promise<PTProvisionResult>>& value) {
    return Result<std::shared_ptr<Promise<PTProvisionResult>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_PTProvisionResult___ create_Result_std__shared_ptr_Promise_PTProvisionResult___(const std::exception_ptr& error) {
    return Result<std::shared_ptr<Promise<PTProvisionResult>>>::withError(error);
  }
  
  // pragma MARK: Result<PTBooleanResult>
  using Result_PTBooleanResult_ = Result<PTBooleanResult>;
  inline Result_PTBooleanResult_ create_Result_PTBooleanResult_(const PTBooleanResult& value) {
    return Result<PTBooleanResult>::withValue(value);
  }
  inline Result_PTBooleanResult_ create_Result_PTBooleanResult_(const std::exception_ptr& error) {
    return Result<PTBooleanResult>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<PTStringResult>>>
  using Result_std__shared_ptr_Promise_PTStringResult___ = Result<std::shared_ptr<Promise<PTStringResult>>>;
  inline Result_std__shared_ptr_Promise_PTStringResult___ create_Result_std__shared_ptr_Promise_PTStringResult___(const std::shared_ptr<Promise<PTStringResult>>& value) {
    return Result<std::shared_ptr<Promise<PTStringResult>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_PTStringResult___ create_Result_std__shared_ptr_Promise_PTStringResult___(const std::exception_ptr& error) {
    return Result<std::shared_ptr<Promise<PTStringResult>>>::withError(error);
  }
  
  // pragma MARK: Result<PTStringResult>
  using Result_PTStringResult_ = Result<PTStringResult>;
  inline Result_PTStringResult_ create_Result_PTStringResult_(const PTStringResult& value) {
    return Result<PTStringResult>::withValue(value);
  }
  inline Result_PTStringResult_ create_Result_PTStringResult_(const std::exception_ptr& error) {
    return Result<PTStringResult>::withError(error);
  }
  
  // pragma MARK: Result<double>
  using Result_double_ = Result<double>;
  inline Result_double_ create_Result_double_(double value) {
    return Result<double>::withValue(std::move(value));
  }
  inline Result_double_ create_Result_double_(const std::exception_ptr& error) {
    return Result<double>::withError(error);
  }
  
  // pragma MARK: Result<PTLocationAccess>
  using Result_PTLocationAccess_ = Result<PTLocationAccess>;
  inline Result_PTLocationAccess_ create_Result_PTLocationAccess_(PTLocationAccess value) {
    return Result<PTLocationAccess>::withValue(std::move(value));
  }
  inline Result_PTLocationAccess_ create_Result_PTLocationAccess_(const std::exception_ptr& error) {
    return Result<PTLocationAccess>::withError(error);
  }

} // namespace margelo::nitro::espprovtoolkit::bridge::swift
