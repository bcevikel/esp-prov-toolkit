///
/// HybridEspProvToolkitSpec.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#if __has_include(<NitroModules/HybridObject.hpp>)
#include <NitroModules/HybridObject.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif

// Forward declaration of `PTSearchResult` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { struct PTSearchResult; }
// Forward declaration of `PTTransport` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { enum class PTTransport; }
// Forward declaration of `PTSecurity` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { enum class PTSecurity; }
// Forward declaration of `PTResult` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { struct PTResult; }
// Forward declaration of `PTDeviceResult` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { struct PTDeviceResult; }
// Forward declaration of `PTWifiScanResult` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { struct PTWifiScanResult; }
// Forward declaration of `PTSessionResult` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { struct PTSessionResult; }
// Forward declaration of `PTProvisionResult` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { struct PTProvisionResult; }
// Forward declaration of `PTBooleanResult` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { struct PTBooleanResult; }
// Forward declaration of `PTStringResult` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { struct PTStringResult; }
// Forward declaration of `PTLocationAccess` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { enum class PTLocationAccess; }
// Forward declaration of `PTError` to properly resolve imports.
namespace margelo::nitro::espprovtoolkit { enum class PTError; }

#include <NitroModules/Promise.hpp>
#include "PTSearchResult.hpp"
#include <string>
#include "PTTransport.hpp"
#include "PTSecurity.hpp"
#include "PTResult.hpp"
#include <optional>
#include "PTDeviceResult.hpp"
#include "PTWifiScanResult.hpp"
#include "PTSessionResult.hpp"
#include "PTProvisionResult.hpp"
#include "PTBooleanResult.hpp"
#include "PTStringResult.hpp"
#include <functional>
#include "PTLocationAccess.hpp"
#include "PTError.hpp"

namespace margelo::nitro::espprovtoolkit {

  using namespace margelo::nitro;

  /**
   * An abstract base class for `EspProvToolkit`
   * Inherit this class to create instances of `HybridEspProvToolkitSpec` in C++.
   * You must explicitly call `HybridObject`'s constructor yourself, because it is virtual.
   * @example
   * ```cpp
   * class HybridEspProvToolkit: public HybridEspProvToolkitSpec {
   * public:
   *   HybridEspProvToolkit(...): HybridObject(TAG) { ... }
   *   // ...
   * };
   * ```
   */
  class HybridEspProvToolkitSpec: public virtual HybridObject {
    public:
      // Constructor
      explicit HybridEspProvToolkitSpec(): HybridObject(TAG) { }

      // Destructor
      ~HybridEspProvToolkitSpec() override = default;

    public:
      // Properties
      

    public:
      // Methods
      virtual std::shared_ptr<Promise<PTSearchResult>> searchForESPDevices(const std::string& devicePrefix, PTTransport transport, PTSecurity security) = 0;
      virtual void stopSearchingForESPDevices() = 0;
      virtual std::shared_ptr<Promise<PTResult>> createESPDevice(const std::string& deviceName, PTTransport transport, PTSecurity security, const std::optional<std::string>& proofOfPossession, const std::optional<std::string>& softAPPassword, const std::optional<std::string>& username) = 0;
      virtual PTDeviceResult getESPDevice(const std::string& deviceName) = 0;
      virtual bool doesESPDeviceExist(const std::string& deviceName) = 0;
      virtual std::shared_ptr<Promise<PTWifiScanResult>> scanWifiListOfESPDevice(const std::string& deviceName) = 0;
      virtual std::shared_ptr<Promise<PTSessionResult>> connectToESPDevice(const std::string& deviceName) = 0;
      virtual PTResult disconnectFromESPDevice(const std::string& deviceName) = 0;
      virtual std::shared_ptr<Promise<PTSessionResult>> createSessionWithESPDevice(const std::string& deviceName) = 0;
      virtual std::shared_ptr<Promise<PTProvisionResult>> provisionESPDevice(const std::string& deviceName, const std::string& ssid, const std::string& password) = 0;
      virtual PTBooleanResult isESPDeviceSessionEstablished(const std::string& deviceName) = 0;
      virtual std::shared_ptr<Promise<PTStringResult>> sendDataToESPDevice(const std::string& deviceName, const std::string& path, const std::string& data) = 0;
      virtual PTStringResult getIPv4AddressOfESPDevice(const std::string& deviceName) = 0;
      virtual PTStringResult getCurrentNetworkSSID() = 0;
      virtual void requestLocationPermission() = 0;
      virtual double registerLocationStatusCallback(const std::function<std::shared_ptr<Promise<bool>>(PTLocationAccess /* level */)>& callback) = 0;
      virtual bool removeLocationStatusCallback(double id) = 0;
      virtual PTLocationAccess getCurrentLocationStatus() = 0;
      virtual double nativeErrorToNumber(PTError error) = 0;

    protected:
      // Hybrid Setup
      void loadHybridMethods() override;

    protected:
      // Tag for logging
      static constexpr auto TAG = "EspProvToolkit";
  };

} // namespace margelo::nitro::espprovtoolkit
